@[TOC](MySQL复习)

# 索引

## 索引的使用场景

 - 针对经常用在条件中的字段上
 - 查找的次数远远高于修改的次数
 - 表中的行数足够大

## 索引的使用

创建主键约束（**PRIMARY KEY**）、唯一约束（**UNIQUE**）、外键约束（**FOREIGN KEY**）时，会自动创建对应列的索引。

 - **查看索引**

> ==<code>show index</code> from 表名;==

 - **创建索引**

对于非主键、非唯一约束、非外键的字段，可以创建普通索引

> ==<code>create index</code> 索引名 <code>on</code> 表名(字段名);==

 - **删除索引**

> ==<code>drop index</code> 索引名 <code>on</code> 表名;==

索引保存的数据结构主要为**B+树**，及**hash**的方式.

## 索引的分类

从使用者的角度分类：

 - 主键索引（也有语义上的约束）
 - 唯一键索引（也有语义上的约束）
 - 普通索引（没有语义上的约束，纯粹是为了提升查询速度而使用）

聚集索引（索引之间有关系）和联合索引（key是由多个字段放在一起组成的）
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210625090515679.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjYxMTI1,size_16,color_FFFFFF,t_70)




## 索引的注意事项

 - 索引的创建是非常耗时的也会耗费大量的空间，数据量越大索引的创建时间也就越长，所以生产环境下慎用
 - 索引它适用场景时读取比较多的情况，如果操作（新增、删除）比较多的不建议使用（B+树删除会重新构建，比较费时）

面试题：什么情况下索引会不生效？

 - 使用like查询有可能不生效，like'%xxx%'不走索引，而like'x%'生效（必须以x开头，不能以%开头）
 - 尽量避免使用or查询，有可能会导致查询不生效
 - 尽量不使用is not in查询语句，也会导致索引不生效
 - ！=、<>导致索引不生效，尽量不要使用
 - 对于组合索引来说一定要遵守最左匹配原则，否则索引也不生效。


# 事务

## 事物的概念

事务指逻辑上的一组操作，组成这组操作的各个单元，**要么全部成功，要么全部失败**。 在不同的环境中，都可以有事务。对应在数据库中，就是数据库事务。

## 事务的四大特征（ACID）

 - **原子性**：要么全部成功，要么全部失败（补偿机制）
 - **持久性**：事务执行的结果一定要永久的保存下来
 - **一致性**：事务执行之前和执行之后，数据要保证修改的正确性
 - **隔离性**：多个事务在执行的事务要相互隔离

## MySQL事务执行时的三个问题

 - 脏读：事务A在执行的时候，读取到了正在执行的事务B的数据，事务B进行了回滚数据
 - 不可重复读：事务A使用同一个查询条件，读取到的内容不一致（因为在这个过程中事务B<code>修改了数据）
 - 幻读：事务A使用相同的查询添加，两次查询的结果不一样，因为事务B进行了<code>添加或删除了数据

**经典面试题：不可重复度和幻读的区别？**
二者的侧重点不同，不可重复读的侧重点是修改数据，而幻读的侧重点是添加或者删除数据

## MySQL的隔离级别

SQL标准定义了4类隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。

 - **读未提交**

在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。

 - **读已提交**

这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别也支持所谓的不可重复读，因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。

 - **可重入读**

是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，）机制解决了该问题。

 - **串行化**

这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210624231214663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NjYxMTI1,size_16,color_FFFFFF,t_70)

## 事务的使用

事务三板斧

 - （1）开启事务：start transaction;
 - （2）执行多条SQL语句
 - （3）回滚或提交：rollback/commit;
